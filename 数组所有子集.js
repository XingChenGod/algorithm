/*
* 由于数组的长度可以为无限大，这让我们无从下手。不过，算法毕竟是逐步实现的，我们可以从小规模的问题入手。这时，我们把问题规模缩小一点，减少我们思考的范围。先思考一个元素，那无非就是选和不选，我们假定一开始数组是空的，那么在做完第一次选择之后，应该有两个数组[[], [e_1]][[],[e
1
​
 ]]。然后，我们再考虑第二个元素，则有[[], [e_1], [e_2], [e_1, e_2]][[],[e
1
​
 ],[e
2
​
 ],[e
1
​
 ,e
2
​
 ]]。发现了吗？这里存在一个规律，[[]] \rightarrow [[], [e_1]] \rightarrow [[], [e_1], [e_2], [e_1, e_2]][[]]→[[],[e
1
​
 ]]→[[],[e
1
​
 ],[e
2
​
 ],[e
1
​
 ,e
2
​
 ]]，每次做选择之后的结果都是在上一步已知的集合上进行扩充得到的，即当前的集合_i = 集合_{i-1} \bigcup 从集合_{i-1}扩充后的集合当前的集合
i
​
 =集合
i−1
​
 ⋃从集合
i−1
​
 扩充后的集合。那么，扩充的方式就是对集合_{i-1}集合
i−1
​
 中的每个子集加上一个新的元素e_ie
i
​
* */

function subsets(nums) {
    const res = [[]];
    for (let i = 0; i < nums.length; i ++) {
        for (let j = 0, len = res.length; j < len; j ++) {
            res.push(res[j].concat([nums[i]]));
        }
    }
    return res;
}

console.log(subsets([1, 2, 3]));
